<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rama de Base de Datos 3D - Hologr√°fica</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            background: rgba(0, 20, 40, 0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 100;
            border: 1px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        #info h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
        }

        #info p {
            margin: 5px 0;
            font-size: 14px;
            line-height: 1.4;
            color: #99e6ff;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <div id="info">
        <h3>üå≥ √Årbol de Conocimiento IT</h3>
        <p>7 Ramas: BD ‚Ä¢ Web ‚Ä¢ IA ‚Ä¢ Seguridad ‚Ä¢ Cloud ‚Ä¢ DevOps ‚Ä¢ Redes</p>
        <p>Haz clic en el tronco o en los nodos</p>
        <p>Arrastra para rotar | Scroll para zoom</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, raycaster, mouse;
        let nodes = [];
        let trunkMesh = null;
        let particles = [];
        let infoDiv = document.getElementById('info');

        // Datos de las siete ramas principales
        const branches = [
            {
                name: "Base de Datos",
                description: "Sistemas organizados para almacenar, gestionar y recuperar informaci√≥n de manera eficiente.",
                position: { x: 0, y: 0, z: 0 },
                size: 0.5,
                color: 0x00ffff,
                offset: { x: 0, z: 0 },
                subNodes: [
                    { name: "SQL", description: "Lenguaje est√°ndar para gesti√≥n de bases de datos relacionales", color: 0x00ffff },
                    { name: "NoSQL", description: "Bases de datos no relacionales para datos no estructurados", color: 0x00ff88 },
                    { name: "Normalizaci√≥n", description: "Proceso de organizar datos para reducir redundancia", color: 0x0088ff },
                    { name: "√çndices", description: "Estructuras para acelerar consultas de datos", color: 0x8800ff },
                    { name: "Transacciones", description: "Operaciones at√≥micas que garantizan integridad de datos", color: 0x00ffcc },
                    { name: "Backup", description: "Copias de seguridad para proteger contra p√©rdida de datos", color: 0xff00ff },
                    { name: "Replicaci√≥n", description: "Copia de datos en m√∫ltiples servidores", color: 0x00ccff },
                    { name: "Optimizaci√≥n", description: "Mejora del rendimiento de consultas y operaciones", color: 0x66ffff }
                ]
            },
            {
                name: "Base de Datos",
                description: "Sistemas organizados para almacenar, gestionar y recuperar informaci√≥n de manera eficiente.",
                position: { x: 0, y: 0, z: 0 },
                size: 0.5,
                color: 0x00ffff,
                offset: { x: 0, z: 0 },
                subNodes: [
                    { name: "SQL", description: "Lenguaje est√°ndar para gesti√≥n de bases de datos relacionales", color: 0x00ffff },
                    { name: "NoSQL", description: "Bases de datos no relacionales para datos no estructurados", color: 0x00ff88 },
                    { name: "Normalizaci√≥n", description: "Proceso de organizar datos para reducir redundancia", color: 0x0088ff },
                    { name: "√çndices", description: "Estructuras para acelerar consultas de datos", color: 0x8800ff },
                    { name: "Transacciones", description: "Operaciones at√≥micas que garantizan integridad de datos", color: 0x00ffcc },
                    { name: "Backup", description: "Copias de seguridad para proteger contra p√©rdida de datos", color: 0xff00ff },
                    { name: "Replicaci√≥n", description: "Copia de datos en m√∫ltiples servidores", color: 0x00ccff },
                    { name: "Optimizaci√≥n", description: "Mejora del rendimiento de consultas y operaciones", color: 0x66ffff }
                ]
            },
            {
                name: "Desarrollo Web",
                description: "Tecnolog√≠as y frameworks para crear aplicaciones y sitios web modernos.",
                position: { x: -6, y: 0, z: 0 },
                size: 0.5,
                color: 0xff6600,
                offset: { x: -6, z: 0 },
                subNodes: [
                    { name: "HTML/CSS", description: "Lenguajes fundamentales para estructura y dise√±o web", color: 0xff6600 },
                    { name: "JavaScript", description: "Lenguaje de programaci√≥n para interactividad web", color: 0xffaa00 },
                    { name: "React", description: "Biblioteca para construir interfaces de usuario", color: 0xff8800 },
                    { name: "Node.js", description: "Entorno de ejecuci√≥n JavaScript del lado del servidor", color: 0xffcc00 },
                    { name: "APIs REST", description: "Arquitectura para servicios web", color: 0xff9900 },
                    { name: "Responsive", description: "Dise√±o adaptable a diferentes dispositivos", color: 0xffbb00 },
                    { name: "TypeScript", description: "Superconjunto tipado de JavaScript", color: 0xff7700 },
                    { name: "Webpack", description: "Empaquetador de m√≥dulos para aplicaciones", color: 0xffdd00 }
                ]
            },
            {
                name: "Inteligencia Artificial",
                description: "Sistemas que simulan inteligencia humana mediante algoritmos y modelos.",
                position: { x: 6, y: 0, z: 0 },
                size: 0.5,
                color: 0xff00ff,
                offset: { x: 6, z: 0 },
                subNodes: [
                    { name: "Machine Learning", description: "Algoritmos que aprenden de datos", color: 0xff00ff },
                    { name: "Deep Learning", description: "Redes neuronales profundas", color: 0xdd00ff },
                    { name: "NLP", description: "Procesamiento de lenguaje natural", color: 0xff00dd },
                    { name: "Computer Vision", description: "Procesamiento y an√°lisis de im√°genes", color: 0xbb00ff },
                    { name: "Redes Neuronales", description: "Modelos inspirados en el cerebro", color: 0xff00bb },
                    { name: "TensorFlow", description: "Framework de ML de c√≥digo abierto", color: 0xcc00ff },
                    { name: "PyTorch", description: "Biblioteca de ML con computaci√≥n tensorial", color: 0xff00cc },
                    { name: "Reinforcement Learning", description: "Aprendizaje por refuerzo", color: 0xee00ff }
                ]
            },
            {
                name: "Ciberseguridad",
                description: "Protecci√≥n de sistemas, redes y datos contra ataques y amenazas digitales.",
                position: { x: -4, y: 2, z: -3 },
                size: 0.5,
                color: 0xff0000,
                offset: { x: -4, z: -3 },
                subNodes: [
                    { name: "Criptograf√≠a", description: "T√©cnicas para proteger informaci√≥n", color: 0xff0000 },
                    { name: "Firewalls", description: "Barreras de seguridad de red", color: 0xff3333 },
                    { name: "Pentesting", description: "Pruebas de penetraci√≥n √©tica", color: 0xff6666 },
                    { name: "Autenticaci√≥n", description: "Verificaci√≥n de identidad de usuarios", color: 0xff1111 },
                    { name: "Malware", description: "An√°lisis y prevenci√≥n de software malicioso", color: 0xff4444 },
                    { name: "SSL/TLS", description: "Protocolos de seguridad en la comunicaci√≥n", color: 0xff2222 },
                    { name: "VPN", description: "Redes privadas virtuales seguras", color: 0xff5555 },
                    { name: "Zero Trust", description: "Modelo de seguridad sin confianza impl√≠cita", color: 0xff7777 }
                ]
            },
            {
                name: "Cloud Computing",
                description: "Servicios de computaci√≥n, almacenamiento y procesamiento a trav√©s de internet.",
                position: { x: 4, y: 2, z: -3 },
                size: 0.5,
                color: 0x00ff00,
                offset: { x: 4, z: -3 },
                subNodes: [
                    { name: "AWS", description: "Amazon Web Services plataforma cloud", color: 0x00ff00 },
                    { name: "Azure", description: "Plataforma cloud de Microsoft", color: 0x33ff33 },
                    { name: "GCP", description: "Google Cloud Platform", color: 0x66ff66 },
                    { name: "Docker", description: "Contenedorizaci√≥n de aplicaciones", color: 0x11ff11 },
                    { name: "Kubernetes", description: "Orquestaci√≥n de contenedores", color: 0x44ff44 },
                    { name: "Serverless", description: "Computaci√≥n sin gesti√≥n de servidores", color: 0x22ff22 },
                    { name: "Microservicios", description: "Arquitectura de servicios independientes", color: 0x55ff55 },
                    { name: "IaaS/PaaS", description: "Modelos de servicio cloud", color: 0x77ff77 }
                ]
            },
            {
                name: "DevOps",
                description: "Pr√°cticas que combinan desarrollo de software y operaciones IT.",
                position: { x: -4, y: -2, z: 3 },
                size: 0.5,
                color: 0xffff00,
                offset: { x: -4, z: 3 },
                subNodes: [
                    { name: "CI/CD", description: "Integraci√≥n y despliegue continuos", color: 0xffff00 },
                    { name: "Git", description: "Sistema de control de versiones", color: 0xffff33 },
                    { name: "Jenkins", description: "Servidor de automatizaci√≥n", color: 0xffff66 },
                    { name: "Ansible", description: "Automatizaci√≥n de configuraci√≥n", color: 0xffff11 },
                    { name: "Terraform", description: "Infraestructura como c√≥digo", color: 0xffff44 },
                    { name: "Monitoring", description: "Supervisi√≥n de sistemas y aplicaciones", color: 0xffff22 },
                    { name: "GitLab", description: "Plataforma DevOps completa", color: 0xffff55 },
                    { name: "Prometheus", description: "Sistema de monitoreo y alertas", color: 0xffff77 }
                ]
            },
            {
                name: "Redes",
                description: "Infraestructura y protocolos para comunicaci√≥n entre dispositivos.",
                position: { x: 4, y: -2, z: 3 },
                size: 0.5,
                color: 0x00ffaa,
                offset: { x: 4, z: 3 },
                subNodes: [
                    { name: "TCP/IP", description: "Protocolos fundamentales de internet", color: 0x00ffaa },
                    { name: "DNS", description: "Sistema de nombres de dominio", color: 0x33ffbb },
                    { name: "Routers", description: "Dispositivos de enrutamiento de red", color: 0x66ffcc },
                    { name: "LAN/WAN", description: "Redes locales y de √°rea amplia", color: 0x11ffaa },
                    { name: "VLANs", description: "Redes virtuales de √°rea local", color: 0x44ffbb },
                    { name: "BGP", description: "Protocolo de enrutamiento de frontera", color: 0x22ffaa },
                    { name: "Load Balancing", description: "Distribuci√≥n de carga de red", color: 0x55ffcc },
                    { name: "SDN", description: "Redes definidas por software", color: 0x77ffdd }
                ]
            }
        ];

        function init() {
            // Escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000510);
            scene.fog = new THREE.FogExp2(0x000510, 0.05);

            // C√°mara
            // C√°mara con mayor libertad
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 2, 12);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controles avanzados de c√°mara
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;        // Movimiento suave
            controls.dampingFactor = 0.05;
            controls.enablePan = true;            // Mover lateralmente
            controls.enableZoom = true;           // Zoom con scroll
            controls.enableRotate = true;         // Rotaci√≥n libre
            controls.minDistance = 2;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI;     // Permite rotar 360¬∞


            // Renderer
            //renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Luces
            const ambientLight = new THREE.AmbientLight(0x0066ff, 0.3);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0x00ffff, 1, 100);
            pointLight.position.set(0, 5, 5);
            scene.add(pointLight);

            const pointLight2 = new THREE.PointLight(0xff00ff, 0.5, 100);
            pointLight2.position.set(-5, 0, -5);
            scene.add(pointLight2);

            // Raycaster para detecci√≥n de clics
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Crear tronco principal
            createTrunk();

            // Crear las tres ramas hologr√°ficas
            createHolographicBranches();

            // Crear nodos principales y sub-nodos para cada rama
            branches.forEach(branch => {
                createMainNode(branch);
                createSubNodes(branch);
            });

            // Crear part√≠culas
            createParticles();

            // Controles simples con mouse
            //setupControls();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMouseClick);

            animate();
        }

        function createTrunk() {
            const trunkGroup = new THREE.Group();

            // Crear curva para el tronco con ligera curvatura
            const trunkCurve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(0, -8, 0),
                new THREE.Vector3(-0.3, -6, 0.2),
                new THREE.Vector3(0.3, -4, -0.2),
                new THREE.Vector3(0, -3, 0)
            );

            // Tronco principal m√°s grande con curvatura
            const trunkGeometry = new THREE.TubeGeometry(trunkCurve, 32, 0.5, 16, false);
            const trunkMaterial = new THREE.MeshPhongMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.5,
                emissive: 0x0088cc,
                emissiveIntensity: 0.6,
                shininess: 100
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.userData = {
                name: "Inform√°tica",
                description: "Campo de estudio que abarca el procesamiento autom√°tico de informaci√≥n mediante sistemas computacionales. Incluye teor√≠a, dise√±o, desarrollo y aplicaci√≥n de sistemas de software y hardware para resolver problemas y automatizar procesos en diversos √°mbitos."
            };
            trunkMesh = trunk;
            trunkGroup.add(trunk);

            // Bordes del tronco
            const edgesGeometry = new THREE.EdgesGeometry(trunkGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffff,
                linewidth: 2
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            trunkGroup.add(edges);

            // Anillos hologr√°ficos en el tronco siguiendo la curva
            const trunkPoints = trunkCurve.getPoints(12);
            trunkPoints.forEach((point, i) => {
                const ringSize = 0.55 - i * 0.02;
                const ringGeometry = new THREE.TorusGeometry(ringSize, 0.025, 8, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.4 - i * 0.02,
                    wireframe: true
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(point);
                ring.rotation.x = Math.PI / 2;

                // Orientar el anillo perpendicular a la tangente
                if (i < trunkPoints.length - 1) {
                    const tangent = new THREE.Vector3().subVectors(trunkPoints[i + 1], point).normalize();
                    ring.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tangent);
                }

                trunkGroup.add(ring);
            });

            // Part√≠culas en el tronco
            for (let i = 0; i < 50; i++) {
                const t = Math.random();
                const pos = trunkCurve.getPoint(t);
                const particleGeo = new THREE.SphereGeometry(0.03, 8, 8);
                const particleMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(pos);
                particle.position.x += (Math.random() - 0.5) * 0.8;
                particle.position.z += (Math.random() - 0.5) * 0.8;
                trunkGroup.add(particle);
            }

            // L√≠neas verticales para dar textura al tronco
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const linePoints = trunkPoints.map(p => {
                    return new THREE.Vector3(
                        p.x + Math.cos(angle) * 0.45,
                        p.y,
                        p.z + Math.sin(angle) * 0.45
                    );
                });
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x0088ff,
                    transparent: true,
                    opacity: 0.3
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                trunkGroup.add(line);
            }

            scene.add(trunkGroup);
        }

        function createHolographicBranches() {
            // Crear siete ramas con m√∫ltiples curvas (3 curvas cada una)
            const branchConfigs = [
                {
                    points: [
                        new THREE.Vector3(0, -3, 0),
                        new THREE.Vector3(-0.8, -1.5, 0.3),
                        new THREE.Vector3(0.5, 0, -0.2),
                        new THREE.Vector3(-0.3, 1.5, 0.4),
                        new THREE.Vector3(0, 3, 0)
                    ],
                    color: 0x00ffff,
                    radius: 0.15
                },
                {
                    points: [
                        new THREE.Vector3(0, -3, 0),
                        new THREE.Vector3(-2, -1.5, -1),
                        new THREE.Vector3(-4, 0, -0.5),
                        new THREE.Vector3(-5.5, 1.5, 0.2),
                        new THREE.Vector3(-6, 3, 0)
                    ],
                    color: 0xff6600,
                    radius: 0.12
                },
                {
                    points: [
                        new THREE.Vector3(0, -3, 0),
                        new THREE.Vector3(2, -1.5, 1),
                        new THREE.Vector3(4, 0, 0.5),
                        new THREE.Vector3(5.5, 1.5, -0.2),
                        new THREE.Vector3(6, 3, 0)
                    ],
                    color: 0xff00ff,
                    radius: 0.12
                },
                {
                    points: [
                        new THREE.Vector3(0, -3, 0),
                        new THREE.Vector3(-1.5, -1.5, -1.5),
                        new THREE.Vector3(-3, 0, -2.5),
                        new THREE.Vector3(-3.8, 1.5, -3.2),
                        new THREE.Vector3(-4, 3, -3)
                    ],
                    color: 0xff0000,
                    radius: 0.10
                },
                {
                    points: [
                        new THREE.Vector3(0, -3, 0),
                        new THREE.Vector3(1.5, -1.5, -1.5),
                        new THREE.Vector3(3, 0, -2.5),
                        new THREE.Vector3(3.8, 1.5, -3.2),
                        new THREE.Vector3(4, 3, -3)
                    ],
                    color: 0x00ff00,
                    radius: 0.10
                },
                {
                    points: [
                        new THREE.Vector3(0, -3, 0),
                        new THREE.Vector3(-1.5, -1.5, 1.5),
                        new THREE.Vector3(-3, 0, 2.5),
                        new THREE.Vector3(-3.8, 1.5, 3.2),
                        new THREE.Vector3(-4, 3, 3)
                    ],
                    color: 0xffff00,
                    radius: 0.10
                },
                {
                    points: [
                        new THREE.Vector3(0, -3, 0),
                        new THREE.Vector3(1.5, -1.5, 1.5),
                        new THREE.Vector3(3, 0, 2.5),
                        new THREE.Vector3(3.8, 1.5, 3.2),
                        new THREE.Vector3(4, 3, 3)
                    ],
                    color: 0x00ffaa,
                    radius: 0.10
                }
            ];

            branchConfigs.forEach(config => {
                const branchGroup = new THREE.Group();

                // Crear curva suave que pasa por todos los puntos (CatmullRom para curvas naturales)
                const curve = new THREE.CatmullRomCurve3(config.points);
                curve.tension = 0.5; // Ajusta la tensi√≥n de la curva

                // Crear tuber√≠a a lo largo de la curva
                const tubeGeometry = new THREE.TubeGeometry(curve, 100, config.radius, 16, false);
                const branchMaterial = new THREE.MeshPhongMaterial({
                    color: config.color,
                    transparent: true,
                    opacity: 0.4,
                    emissive: config.color,
                    emissiveIntensity: 0.5,
                    shininess: 100,
                    wireframe: false
                });
                const branch = new THREE.Mesh(tubeGeometry, branchMaterial);
                branchGroup.add(branch);

                // A√±adir bordes brillantes
                const edgesGeometry = new THREE.EdgesGeometry(tubeGeometry);
                const edgesMaterial = new THREE.LineBasicMaterial({
                    color: config.color,
                    linewidth: 2
                });
                const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                branchGroup.add(edges);

                // Anillos hologr√°ficos a lo largo de la curva
                const points = curve.getPoints(20);
                points.forEach((point, i) => {
                    if (i % 2 === 0) { // Solo algunos anillos para no saturar
                        const ringGeometry = new THREE.TorusGeometry(0.2 + i * 0.008, 0.015, 8, 32);
                        const ringMaterial = new THREE.MeshBasicMaterial({
                            color: config.color,
                            transparent: true,
                            opacity: 0.3 - i * 0.012,
                            wireframe: true
                        });
                        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                        ring.position.copy(point);

                        // Orientar el anillo perpendicular a la tangente
                        if (i < points.length - 1) {
                            const tangent = new THREE.Vector3().subVectors(points[i + 1], point).normalize();
                            ring.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), tangent);
                        }

                        branchGroup.add(ring);
                    }
                });

                // Part√≠culas que fluyen a lo largo de la rama
                for (let i = 0; i < 40; i++) {
                    const t = i / 40;
                    const pos = curve.getPoint(t);
                    const particleGeo = new THREE.SphereGeometry(0.025, 8, 8);
                    const particleMat = new THREE.MeshBasicMaterial({
                        color: config.color,
                        transparent: true,
                        opacity: 0.7
                    });
                    const particle = new THREE.Mesh(particleGeo, particleMat);
                    particle.position.copy(pos);
                    branchGroup.add(particle);
                }

                // Esferas en los puntos de control para visualizar las curvas
                config.points.forEach((point, i) => {
                    if (i > 0 && i < config.points.length - 1) { // No mostrar en inicio y fin
                        const sphereGeo = new THREE.SphereGeometry(0.08, 16, 16);
                        const sphereMat = new THREE.MeshBasicMaterial({
                            color: config.color,
                            transparent: true,
                            opacity: 0.4,
                            wireframe: true
                        });
                        const sphere = new THREE.Mesh(sphereGeo, sphereMat);
                        sphere.position.copy(point);
                        branchGroup.add(sphere);
                    }
                });

                scene.add(branchGroup);
            });
        }

        function createMainNode(branch) {
            // Esfera principal con efecto de brillo
            const geometry = new THREE.SphereGeometry(branch.size, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: branch.color,
                transparent: true,
                opacity: 0.7,
                emissive: branch.color,
                emissiveIntensity: 0.8,
                shininess: 100
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(branch.position.x, branch.position.y, branch.position.z);
            sphere.userData = branch;
            scene.add(sphere);
            nodes.push(sphere);

            // A√±adir wireframe exterior
            const wireframeGeo = new THREE.SphereGeometry(branch.size * 1.1, 16, 16);
            const wireframeMat = new THREE.MeshBasicMaterial({
                color: branch.color,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const wireframe = new THREE.Mesh(wireframeGeo, wireframeMat);
            sphere.add(wireframe);

            // Agregar texto
            addLabel(sphere, branch.name, branch.color);
        }

        function createSubNodes(branch) {
            const radius = 2;
            const angleStep = (Math.PI * 2) / branch.subNodes.length;

            branch.subNodes.forEach((nodeData, i) => {
                const angle = i * angleStep;
                const x = branch.offset.x + Math.cos(angle) * radius;
                const z = branch.offset.z + Math.sin(angle) * radius;
                const y = Math.sin(i * 0.5) * 0.5;

                // Crear esfera con efecto hologr√°fico
                const geometry = new THREE.SphereGeometry(0.25, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: nodeData.color,
                    transparent: true,
                    opacity: 0.6,
                    emissive: nodeData.color,
                    emissiveIntensity: 0.7,
                    shininess: 100
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(x, y, z);
                sphere.userData = nodeData;
                scene.add(sphere);
                nodes.push(sphere);

                // Wireframe exterior
                const wireframeGeo = new THREE.SphereGeometry(0.27, 12, 12);
                const wireframeMat = new THREE.MeshBasicMaterial({
                    color: nodeData.color,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.4
                });
                const wireframe = new THREE.Mesh(wireframeGeo, wireframeMat);
                sphere.add(wireframe);

                // Crear l√≠nea conectora hologr√°fica con part√≠culas
                const curve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(branch.offset.x, 0, branch.offset.z),
                    new THREE.Vector3(branch.offset.x + (x - branch.offset.x) * 0.5, y + 0.3, branch.offset.z + (z - branch.offset.z) * 0.5),
                    new THREE.Vector3(x, y, z)
                );
                const points = curve.getPoints(50);
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: nodeData.color,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);

                // A√±adir puntos brillantes a lo largo de la l√≠nea
                for (let j = 0; j < points.length; j += 5) {
                    const dotGeo = new THREE.SphereGeometry(0.02, 8, 8);
                    const dotMat = new THREE.MeshBasicMaterial({
                        color: nodeData.color,
                        transparent: true,
                        opacity: 0.8
                    });
                    const dot = new THREE.Mesh(dotGeo, dotMat);
                    dot.position.copy(points[j]);
                    scene.add(dot);
                }

                // Agregar etiqueta
                addLabel(sphere, nodeData.name, nodeData.color);
            });
        }

        function createParticles() {
            const particleCount = 200;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 10;

                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.3 + 0.5, 1, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
            particles.push(particleSystem);
        }

        function addLabel(object, text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.font = 'bold 24px Arial';

            // Convertir color hex a string CSS
            const colorStr = '#' + ('000000' + color.toString(16)).slice(-6);
            context.fillStyle = colorStr;
            context.textAlign = 'center';
            context.shadowColor = colorStr;
            context.shadowBlur = 10;
            context.fillText(text, 128, 40);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(1, 0.25, 1);
            sprite.position.y = object.geometry.parameters.radius + 0.3;
            object.add(sprite);
        }

        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    camera.position.x += deltaX * 0.01;
                    camera.position.y -= deltaY * 0.01;
                    camera.lookAt(0, 0, 0);

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const direction = e.deltaY > 0 ? 1 : -1;

                camera.position.x += camera.position.x * direction * zoomSpeed;
                camera.position.y += camera.position.y * direction * zoomSpeed;
                camera.position.z += camera.position.z * direction * zoomSpeed;
            });
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Verificar si se hizo clic en el tronco
            if (trunkMesh) {
                const trunkIntersects = raycaster.intersectObject(trunkMesh);
                if (trunkIntersects.length > 0) {
                    const trunkData = trunkMesh.userData;
                    infoDiv.innerHTML = `
                        <h3>üå≥ ${trunkData.name}</h3>
                        <p>${trunkData.description}</p>
                        <p style="font-size: 12px; color: #66ccff; margin-top: 10px;">Haz clic en las ramas para explorar cada √°rea</p>
                    `;
                    return;
                }
            }

            // Verificar si se hizo clic en alg√∫n nodo
            const intersects = raycaster.intersectObjects(nodes);

            if (intersects.length > 0) {
                const selectedNode = intersects[0].object.userData;
                infoDiv.innerHTML = `
                    <h3>${selectedNode.name}</h3>
                    <p>${selectedNode.description}</p>
                    <p style="font-size: 12px; color: #66ccff; margin-top: 10px;">Haz clic en otro nodo para ver m√°s informaci√≥n</p>
                `;

                // Efecto de pulso al seleccionar
                const selected = intersects[0].object;
                selected.scale.set(1.2, 1.2, 1.2);
                setTimeout(() => {
                    selected.scale.set(1, 1, 1);
                }, 200);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Rotaci√≥n suave de nodos
            nodes.forEach((node, i) => {
                node.rotation.y += 0.01;

                // Efecto de pulsaci√≥n
                const scale = 1 + Math.sin(time * 2 + i) * 0.05;
                node.children[0].scale.set(scale, scale, scale);
            });

            // Animaci√≥n de part√≠culas
            particles.forEach(p => {
                p.rotation.y += 0.0005;
                const positions = p.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] += Math.sin(time + i) * 0.001;
                }
                p.geometry.attributes.position.needsUpdate = true;
            });
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>